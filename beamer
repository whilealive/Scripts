#!/bin/bash
# ==================================================================
# FILE     beamer
# MACHINE  all
# INFO     handles resolution in multi-monitor setup with dwm-type
#					 window managers when mirroring is involved
#
# DATE     03.03.2021
# OWNER    Bischofberger
# ==================================================================


# set the following two according to your system
# ----------------------------------------------
INTERNAL="eDP-1"
EXTERNAL_HDMI="HDMI-1"
EXTERNAL_VGA="DP1"
# ----------------------------------------------


# global vars (will be set automatically later)
EXTERNAL=""
RES_INT_x="1"
RES_INT_y="1"
RES_INT_LIST=()
RES_EXT_x="1"
RES_EXT_y="1"
RES_EXT_LIST=()
COMMON_RES="1"
SCALING_FACTOR_xy=("1" "1")

die(){
	echo -e "$0: Error: $1" >&2
	exit 1
}

isValidRes(){
	if [[ $1 =~ ^[0-9]+$ ]] && (( $1 > 0 )); then
		return 0  # 0 = true
	else
		return 1  # 1 = false
	fi
}

usage(){
	echo -e "Usage: $0 [OPTION]

Handles dual-monitor setup with suckless dwm.

If no argument is given, automatic setup ist being executed. In automatic mode
a common resolution will be searched by default and activated if user wishes
to.  If there is no match and hightest external is higher than internal
resolution, panning mode will be activated.\n
Note, that by now (03.2016) there is no proper way to get out of panning mode.
You must kill the Xserver to do so.\n\

-h, --help            Show this help.
-m, --manually        Manually enter desired external monitor resolution.
                      Additional size checks give extra security in this mode.
-f, --force           Same as the \"-m\"-flag but no size checks here.
-s, --scale           Some different approach here: use the xrandr \"scale\" option
                      to downscale the smaller resolution from the larger
-d, --deactivate      Get out of dual-mode. (not working properly for panning yet)
"
}

showAllResolutions(){
	xrandr
	echo ""
}

printResolution(){
	echo "${1}x${2}"
}

getCurrentInternalResolution(){
	local res=`xrandr | awk '/'\*'/ {print $1; exit}'`
  extractResolution RES_INT_x RES_INT_y $res
}

fillListOfInternalResolutions(){
	# awk:	1.) skip lines not beginning with a space and count them (in y)
	#						note that awk sets all variables to 0 by default, so we can
	#						just increment them whithout initialization
	#				2.) stop extracting numbers after three lines having no space at
	#						the beginning (see output of xrandr)
	local res=`xrandr | awk '!/'^\ '/ {++n;next} n<3 {print $1}'`
	RES_INT_LIST=($res)
}

# TODO: let choose from HDMI1, HDMI2, DP1, DP2 and so on...
chooseOutput(){
  echo "Enter Output option:"
  echo -e "1\tHDMI\n2\tVGA"
  read op
  case "$op" in
    "1")
      EXTERNAL="$EXTERNAL_HDMI"
      ;;
    "2")
      EXTERNAL="$EXTERNAL_VGA"
      ;;
    *)
      die "unknown parameter '$op'"
      ;;
  esac
}

fillListOfExternalResolutions(){
	local res=`xrandr | awk '/'^$EXTERNAL$'/ {m=1; next} m==1 && !/'^\ '/ {exit} m==1 && /'^\ '/ {print $1}'`
	RES_EXT_LIST=($res)
}

extractResolution(){
	eval "$1="$(echo $3 | awk -F "x" '{print $1}')""
	eval "$2="$(echo $3 | awk -F "x" '{print $2}')""
	if !(isValidRes ${!1} && isValidRes ${!2}) ; then
		die "failed to extract resolution: ${!1} x ${!2}."
	fi
}

getHighestExternalResolutionFromList(){
  extractResolution RES_EXT_x RES_EXT_y ${RES_EXT_LIST[0]}
}

getHighestInternalResolutionFromList(){
  extractResolution RES_INT_x RES_INT_y ${RES_INT_LIST[0]}
}

# search for a match between internal and external list
# match will be saved in COMMON_RES
compareLists(){
	for resInt in "${RES_INT_LIST[@]}" ; do
		for resExt in "${RES_EXT_LIST[@]}" ; do
			if [[ "$resInt" == "$resExt" ]] ; then
				COMMON_RES=$resExt
				unset resInt resExt
				return 0  # 0 = true
			fi
		done
	done
  unset resInt resExt
	return 1  # 1 = false
}

xrandr_activateDualMode_panning(){
	xrandr	--output $INTERNAL --mode $RES_INT_MAX --fb $RES_EXT --panning $RES_EXT* \
					--output $EXTERNAL --mode $RES_EXT --same-as $INTERNAL \
          || die "xrandr failure"
	echo "In order to get out of panning mode, you must kill dwm (Mod1-Shift-q)
				and therefore kill the X-server. (Bug in xrandr, 03.2016)"
}

xrandr_activateDualMode(){
	xrandr --output $EXTERNAL --auto --same-as $INTERNAL --mode `printResolution $RES_EXT_x $RES_EXT_y` \
    || die "xrandr failure"
	xrandr --output $INTERNAL --mode `printResolution $RES_EXT_x $RES_EXT_y` \
    || die "xrandr failure"
}

# TODO: workaround for getting out of panning...
# FIXME: get out of scale mode when external is base resolution
xrandr_deactivateDualMode(){
	#xrandr --output $EXTERNAL_VGA --primary
	#xrandr --output $INTERNAL --primary
	read -p "Plug out external monitor and press [Enter]."
  fillListOfInternalResolutions
  getHighestInternalResolutionFromList
	xrandr --output $INTERNAL --mode `printResolution $RES_INT_x $RES_INT_y` --scale 1x1 || die "xrandr failure"
	xrandr >/dev/null
	xrandr --auto
}

readDesiredExternalResolution(){
	echo "Enter desired resolution of external: [{X}x{Y}]"
	read res  # local not possible due to "read"
  extractResolution RES_EXT_x RES_EXT_y $res
	unset res
}

# Test in Funktion scheint nicht zu gehen...
isExternalGreaterThanInternal(){
	if (( "$RES_EXT_x" > "$RES_INT_x" && "$RES_EXT_y" > "$RES_INT_y" )) ; then
		return 0  # 0 = true
	else
		return 1  # 1 = false
	fi
}

isExternalInInternalList(){
	fillListOfInternalResolutions
	for res in "${RES_INT_LIST[@]}" ; do
    local resX resY
    extractResolution resX resY $res
		unset res
		if (( "$resX" == "$RES_EXT_x" && "$resY" == "$RES_EXT_y" )) ; then
			return 0  # 0 = true
		fi
	done
	return 1  # 1 = false
}

usePanning(){
	echo "panning? [y|n]"
	read panning
	case "$panning" in
		"y")
			unset panning
			return 0  # 0 = true
			;;
		"n")
			unset panning
			return 1  # 1 = false
			;;
		*)
			die "unknown parameter '$panning"
			;;
	esac
}

automatic_panning(){
  getCurrentInternalResolution
  getHighestExternalResolutionFromList
  if isExternalGreaterThanInternal ; then
    echo "We are lucky. External resolution is greater than hightest internal."
    echo "Activating dual-mode with panning..."
    xrandr_activateDualMode_panning
  else
    die "Hightest external resolution (`printResolution $RES_EXT_x $RES_EXT_y`) is smaller than
    highest internal (`printResolution $RES_INT_x $RES_INT_y`). No solution yet..."
  fi
}

# arg1/arg2: base_x/base_y, arg3/arg4: target_x/target_y
computeScalingFactor(){
  eval "SCALING_FACTOR_xy[0]="$(echo "$1/$3" | bc -l)""
  eval "SCALING_FACTOR_xy[1]="$(echo "$2/$4" | bc -l)""
}

# manually but with some tests
setup_m(){
	showAllResolutions
  chooseOutput
	getCurrentInternalResolution
	readDesiredExternalResolution
	if usePanning ; then
		if isExternalGreaterThanInternal ; then
			xrandr_activateDualMode_panning
		else
			die "External screen resolution smaller than internal. Panning not allowed."
		fi
	else  # no panning
		if isExternalInInternalList ; then
			xrandr_activateDualMode
		else
			die "No common screen resolution found. Try \"-f|-force\"."
		fi
	fi
}

# no tests here
setup_force(){
	showAllResolutions
  chooseOutput
	getCurrentInternalResolution
	readDesiredExternalResolution
	if usePanning ; then
		xrandr_activateDualMode_panning
	else
		xrandr_activateDualMode
	fi
}

# fully automatic
setup_a(){
  showAllResolutions
  chooseOutput
  fillListOfInternalResolutions
  fillListOfExternalResolutions
  if compareLists ; then
    echo "Common resolution found: $COMMON_RES"
    echo "Do you want to activate dual-mode with this resolution? [y|n]"
    read answer
    case "$answer" in
      "y")
        extractResolution RES_EXT_x RES_EXT_y $COMMON_RES
        xrandr_activateDualMode
        ;;
      "n")
        echo "Do you want to try panning then? [y|n]"
        read answer
        if [[ "$answer" == "y" ]] ; then
          automatic_panning
        fi
        ;;
      *)
        die "unknown parameter '$answer"
        ;;
    esac
  else
    echo "No common resolution found. Taking highest external resolution."
    automatic_panning
  fi
}

setup_scale(){
  showAllResolutions
  chooseOutput
  fillListOfInternalResolutions
  fillListOfExternalResolutions
  getHighestInternalResolutionFromList  # TODO: to be simplified...
  getHighestExternalResolutionFromList
	if (( "$RES_EXT_x" > "$RES_INT_x" || "$RES_EXT_y" > "$RES_INT_y" )) ; then
  #if isExternalGreaterThanInternal ; then
    echo "Scaling mode: external resolution > internal -> using external as base..."
    computeScalingFactor "$RES_EXT_x" "$RES_EXT_y" "$RES_INT_x" "$RES_INT_y" 
    xrandr --output $EXTERNAL --auto \
           --output $INTERNAL --same-as $EXTERNAL --mode `printResolution $RES_INT_x $RES_INT_y` \
           --scale "${SCALING_FACTOR_xy[0]}x${SCALING_FACTOR_xy[1]}" \
           || die "xrandr (scaling) failure"
  else
    echo "Scaling mode: external resolution <= internal -> using internal as base..."
    computeScalingFactor "$RES_INT_x" "$RES_INT_y" "$RES_EXT_x" "$RES_EXT_y"
    xrandr --output $INTERNAL --auto \
           --output $EXTERNAL --same-as $INTERNAL --mode `printResolution $RES_EXT_x $RES_EXT_y` \
           --scale "${SCALING_FACTOR_xy[0]}x${SCALING_FACTOR_xy[1]}" \
           || die "xrandr (scaling) failure"
  fi
  echo "done."
}

# Main ------------------------------------------------

if [ -z "$1" ] ; then
  # if no argument is given do automatic setup
  setup_a
  exit 0
fi

# handle options
case "$1" in
  "-m"|"--manually")
    setup_m
    ;;
  "-f"|"--force")
    setup_force
    ;;
  "-s"|"--scale")
    setup_scale
    ;;
  "-h"|"--help")
    usage
    ;;
  "-d"|"--deactivate")
    xrandr_deactivateDualMode
    ;;
  *)
    echo "usage: $0 [-m|--manually] [-f|--force] [-d|--deactivate] [-h|--help]"
    die "unknown parameter '$1'"
    ;;
esac

