#!/bin/bash
# ==================================================================
# FILE     pcsync
# MACHINE  all
# INFO     syncs stuff from external HD to local HD and back, 
#          using rsync
#          - USB stick in ext4-format needs user rights after 
#            formatting: cd /run/media/, login as root with su, 
#            chown -R $(hostname):users $(hostname)
#          - NOTE: It is assumed that all participating users are 
#            members of the group "users", otherwhise rsync's --delete 
#            option doesn't work properly.
#
# DATE     12.07.2016
# OWNER    Bischofberger
# ==================================================================

# default options
DRY=""
FORCE=""


die(){
    echo -e "$0: Error: $1" >&2
    exit 1
}

# just a message
nothing_done(){
    echo -e "\nEither answered \"no\" or invalid input."
    echo "Nothing will be done."
    exit 1
}

# use "mount" to scan for mounted disks. 
# Give a choice of possible targets to choose from.
# ---------------------
# $REMOTE       (path of music player/SD-card)
# $STATUSFILE   (for extra protection)
# $INCLUDEFILE  (for rsync)
# ---------------------
diskscan() {
    local MOUNTLIST0=/tmp/mountlist0.tmp
    local MOUNTLIST1=/tmp/mountlist1.tmp

    # list all possibly mounted external disks and save them into a tempfile
    mount | grep 'sd[bcd]\|truecrypt' | awk '$1 {print $3}' > $MOUNTLIST0

    # put line numbers in front
    awk '{ printf("%d)\t%s\n", NR, $0) }' $MOUNTLIST0 > $MOUNTLIST1

    # the custom choice, last line
    echo -e "n)\t custom path" >> $MOUNTLIST1

    # for later check
    local NUMBER_OF_DISKS=`wc -l < $MOUNTLIST1`

    # print list
    echo "List of mounted external disks:"
    cat $MOUNTLIST1 || die "Mountlist not found."
    echo -n -e "\nPlease enter the number of your disk or hit \"n\" for entering a custom path: "

    # input parser
    read answer
    if [[ $answer =~ ^[0-9]+$ ]] && (( answer > 0 && answer <= NUMBER_OF_DISKS )) ; then
        REMOTE=`awk -F '\t' '$1 ~ /^'$answer\)'$/ {print $2}' $MOUNTLIST1`
        echo "Your chosen target: $REMOTE"
    elif [[ $answer == n ]] ; then
        echo -n -e "\nEnter custom path: "
        read -e REMOTE  # -e is for autocomplete
        echo "Your chosen target: $REMOTE"
    else
        die "No valid disk path chosen."
    fi

    # create remote data folder if not existent
    if [ -d $REMOTE/pcsync_data ] ; then
        echo "Using existing folder $REMOTE/pcsync_data."
    else
        echo -n "Folder $REMOTE/pcsync_data not existent. Making one...."
        mkdir $REMOTE/pcsync_data
        echo "done."
    fi

    mkdir $REMOTE/pcsync_extra 2>/dev/null
    STATUSFILE="$REMOTE/pcsync_extra/pcsync-statusfile.txt"
    INCLUDEFILE="$REMOTE/pcsync_extra/pcsync-inclexcl.txt"
    REMOTE="$REMOTE/pcsync_data"
}

create_statusfile(){
    if [ ! -f $STATUSFILE ] ; then
        echo -n "There is no statusfile. Creating one..."
        touch $STATUSFILE
        cat > "$STATUSFILE" <<'EOF'
# ==================================================================
# FILE     pcsync-statusfile
# MACHINE  all
# INFO     gives extra protection from synching the wrong way
#
# DATE     
# OWNER    Bischofberger
# ==================================================================

# last action:
LAST_RUN="init"
EOF
        echo "done."
    fi
}

# allowed arguments: "up"/"down"
update_statusfile(){
    if [ -n "$1" ] ; then
        sed -i s/^LAST_RUN\=.*/LAST_RUN\=$1/ $STATUSFILE  # reset LAST_RUN variable
    fi

}

check_includefile() {
    if [ ! -e $INCLUDEFILE ] ; then
        die "pcsync is a rsync wrapper. Therefore it needs a proper includefile to work.
               Create a file called \"$INCLUDEFILE\" 
               according to the rsync includefile specifications and run pcsync
               again."
    fi
}




#############################
## main script starts here ##
#############################

# handle options
while [ -n "$1" ]; do
    case "$1" in
        "-n"|"--dry-run")
            DRY="-n"
            shift;;
        "-f"|"--force")
            FORCE="-f"
            shift;;
        *)
            echo "usage: $0 [-n|--dry-run] [-f|--force]"
            die "unknown parameter '$1'"
            ;;
    esac
done

# better ask twice...
echo -n "Syncup (up) or Syncdown (down)? "
read answer
if [[ $answer == up ]] ; then
    DIRECTION=up
elif [[ $answer == down ]] ; then
    DIRECTION=down
else
    nothing_done
fi

# set the paths
diskscan

# extra protection through statusfile
create_statusfile
source $STATUSFILE
if [[ $DIRECTION == up && $LAST_RUN == up && $FORCE != -f ]] ; then
    die "You must sync down since your last sync direction was up.
         Use the \"-f\" option to force direction."
fi
if [[ $DIRECTION == down && $LAST_RUN == down && $FORCE != -f ]] ; then
    die "You must sync up since your last sync direction was down
         Use the \"-f\" option to force direction."
fi

# sync
check_includefile
if [[ $DIRECTION == up ]] ; then
    rsync -avu $DRY --delete --include-from="$INCLUDEFILE" $HOME/ $REMOTE/ \
        || die "rsync error"
elif [[ $DIRECTION == down ]] ; then
    rsync -avu $DRY --delete --include-from="$INCLUDEFILE" $REMOTE/ $HOME/ \
        || die "rsync error"
else
    die "direction unknown."
fi

# update statusfile
if [[ $DRY != -n ]] ; then
    update_statusfile $DIRECTION
fi

# end of sync
echo -e "\npcsync ($DIRECTION) successful"
